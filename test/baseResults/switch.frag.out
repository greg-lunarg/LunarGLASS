
Top IR:
; ModuleID = 'Glslang'

@c = external addrspace(2) constant i32
@x = global float 0.000000e+00
@d = external addrspace(2) constant i32
@color = global float 0.000000e+00
@v = external addrspace(2) constant <4 x float>

define fastcc void @main() {
entry:
  %param93 = alloca i32
  %param92 = alloca <4 x float>
  %param91 = alloca <4 x float>
  %param86 = alloca i32
  %param85 = alloca <4 x float>
  %param = alloca <4 x float>
  %j = alloca i32
  %i = alloca i32
  %f = alloca float
  %local = alloca i32
  br label %mainBody

mainBody:                                         ; preds = %entry
  %local1 = load i32 addrspace(2)* @c, !gla.uniform !1
  store i32 %local1, i32* %local
  %0 = load i32* %local
  %local2 = add i32 %0, 1, !gla.precision !9
  store i32 %local2, i32* %local
  %1 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %1, label %switch-segment4 [
    i32 1, label %switch-segment
    i32 2, label %switch-segment3
  ]

switch-segment:                                   ; preds = %mainBody
  %2 = load float* @x
  %f6 = call float @llvm.gla.fSin.f32.f32(float %2), !gla.precision !9
  store float %f6, float* %f
  br label %switch-merge

switch-segment3:                                  ; preds = %mainBody
  %3 = load float* @x
  %f8 = call float @llvm.gla.fCos.f32.f32(float %3), !gla.precision !9
  store float %f8, float* %f
  br label %switch-merge

switch-segment4:                                  ; preds = %mainBody
  %4 = load float* @x
  %f11 = call float @llvm.gla.fTan.f32.f32(float %4), !gla.precision !9
  store float %f11, float* %f
  br label %switch-merge

switch-merge:                                     ; preds = %switch-segment4, %switch-segment3, %switch-segment
  %5 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %5, label %switch-segment15 [
    i32 1, label %switch-segment13
    i32 2, label %switch-segment14
  ]

post-switch-break:                                ; No predecessors!
  unreachable

post-switch-break9:                               ; No predecessors!
  unreachable

post-switch-break12:                              ; No predecessors!
  unreachable

switch-segment13:                                 ; preds = %switch-merge
  %6 = load float* @x
  %f17 = call float @llvm.gla.fSin.f32.f32(float %6), !gla.precision !9
  %7 = load float* %f
  %f18 = fadd float %7, %f17, !gla.precision !9
  store float %f18, float* %f
  br label %switch-segment14

switch-segment14:                                 ; preds = %switch-segment13, %switch-merge
  %8 = load float* @x
  %f19 = call float @llvm.gla.fCos.f32.f32(float %8), !gla.precision !9
  %9 = load float* %f
  %f20 = fadd float %9, %f19, !gla.precision !9
  store float %f20, float* %f
  br label %switch-merge16

switch-segment15:                                 ; preds = %switch-merge
  %10 = load float* @x
  %f22 = call float @llvm.gla.fTan.f32.f32(float %10), !gla.precision !9
  %11 = load float* %f
  %f23 = fadd float %11, %f22, !gla.precision !9
  store float %f23, float* %f
  br label %switch-merge16

switch-merge16:                                   ; preds = %switch-segment15, %switch-segment14
  %12 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %12, label %switch-merge27 [
    i32 1, label %switch-segment25
    i32 2, label %switch-segment26
  ]

post-switch-break21:                              ; No predecessors!
  unreachable

post-switch-break24:                              ; No predecessors!
  unreachable

switch-segment25:                                 ; preds = %switch-merge16
  %13 = load float* @x
  %f28 = call float @llvm.gla.fSin.f32.f32(float %13), !gla.precision !9
  %14 = load float* %f
  %f29 = fadd float %14, %f28, !gla.precision !9
  store float %f29, float* %f
  br label %switch-merge27

switch-segment26:                                 ; preds = %switch-merge16
  %15 = load float* @x
  %f31 = call float @llvm.gla.fCos.f32.f32(float %15), !gla.precision !9
  %16 = load float* %f
  %f32 = fadd float %16, %f31, !gla.precision !9
  store float %f32, float* %f
  br label %switch-merge27

switch-merge27:                                   ; preds = %switch-segment26, %switch-segment25, %switch-merge16
  %17 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %17, label %switch-segment36 [
    i32 1, label %switch-segment34
    i32 2, label %switch-segment35
  ]

post-switch-break30:                              ; No predecessors!
  unreachable

post-switch-break33:                              ; No predecessors!
  unreachable

switch-segment34:                                 ; preds = %switch-merge27
  %18 = load float* @x
  %f38 = call float @llvm.gla.fSin.f32.f32(float %18), !gla.precision !9
  %19 = load float* %f
  %f39 = fadd float %19, %f38, !gla.precision !9
  store float %f39, float* %f
  br label %switch-merge37

switch-segment35:                                 ; preds = %switch-merge27
  %20 = load i32 addrspace(2)* @d, !gla.uniform !3
  switch i32 %20, label %switch-merge43 [
    i32 1, label %switch-segment41
    i32 2, label %switch-segment42
  ]

switch-segment36:                                 ; preds = %switch-merge27
  %21 = load float* @x
  %f49 = call float @llvm.gla.fTan.f32.f32(float %21), !gla.precision !9
  %22 = load float* %f
  %f50 = fadd float %22, %f49, !gla.precision !9
  store float %f50, float* %f
  br label %switch-merge37

switch-merge37:                                   ; preds = %switch-segment36, %switch-merge43, %switch-segment34
  store i32 0, i32* %i
  br label %loop-header

post-switch-break40:                              ; No predecessors!
  unreachable

switch-segment41:                                 ; preds = %switch-segment35
  %23 = load float* @x
  %24 = load float* @x
  %25 = fmul float %23, %24, !gla.precision !9
  %26 = load float* @x
  %27 = fmul float %25, %26, !gla.precision !9
  %28 = load float* %f
  %f44 = fadd float %28, %27, !gla.precision !9
  store float %f44, float* %f
  br label %switch-merge43

switch-segment42:                                 ; preds = %switch-segment35
  %29 = load float* @x
  %30 = load float* @x
  %31 = fmul float %29, %30, !gla.precision !9
  %32 = load float* %f
  %f46 = fadd float %32, %31, !gla.precision !9
  store float %f46, float* %f
  br label %switch-merge43

switch-merge43:                                   ; preds = %switch-segment42, %switch-segment41, %switch-segment35
  br label %switch-merge37

post-switch-break45:                              ; No predecessors!
  unreachable

post-switch-break47:                              ; No predecessors!
  unreachable

post-switch-break48:                              ; No predecessors!
  unreachable

post-switch-break51:                              ; No predecessors!
  unreachable

loop-header:                                      ; preds = %ifmerge77, %switch-merge37
  %33 = load i32* %i
  %34 = icmp slt i32 %33, 10
  %35 = xor i1 %34, true
  br i1 %35, label %then, label %ifmerge

then:                                             ; preds = %loop-header
  br label %loop-merge79

post-loop-break:                                  ; No predecessors!
  unreachable

ifmerge:                                          ; preds = %loop-header
  %36 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %36, label %switch-segment54 [
    i32 1, label %switch-segment52
    i32 2, label %switch-segment53
  ]

switch-segment52:                                 ; preds = %ifmerge
  %37 = load float* @x
  %f56 = call float @llvm.gla.fSin.f32.f32(float %37), !gla.precision !9
  %38 = load float* %f
  %f57 = fadd float %38, %f56, !gla.precision !9
  store float %f57, float* %f
  store i32 20, i32* %j
  br label %loop-header58

switch-segment53:                                 ; preds = %ifmerge
  %39 = load float* @x
  %f68 = call float @llvm.gla.fCos.f32.f32(float %39), !gla.precision !9
  %40 = load float* %f
  %f69 = fadd float %40, %f68, !gla.precision !9
  store float %f69, float* %f
  br label %switch-merge55

switch-segment54:                                 ; preds = %ifmerge
  %41 = load float* @x
  %f72 = call float @llvm.gla.fTan.f32.f32(float %41), !gla.precision !9
  %42 = load float* %f
  %f73 = fadd float %42, %f72, !gla.precision !9
  store float %f73, float* %f
  br label %switch-merge55

switch-merge55:                                   ; preds = %switch-segment54, %switch-segment53, %loop-merge
  %43 = load float* %f
  %44 = fcmp olt float %43, 0x400B70A3E0000000
  br i1 %44, label %then75, label %ifmerge77

loop-header58:                                    ; preds = %ifmerge65, %switch-segment52
  %45 = load i32* %j
  %46 = icmp slt i32 %45, 30
  %47 = xor i1 %46, true
  br i1 %47, label %then59, label %ifmerge61

then59:                                           ; preds = %loop-header58
  br label %loop-merge

post-loop-break60:                                ; No predecessors!
  unreachable

ifmerge61:                                        ; preds = %loop-header58
  %48 = load float* %f
  %f62 = fadd float %48, 1.000000e+00, !gla.precision !9
  store float %f62, float* %f
  %49 = load float* %f
  %50 = fcmp olt float %49, 0x40590CCCC0000000
  br i1 %50, label %then63, label %ifmerge65

then63:                                           ; preds = %ifmerge61
  br label %loop-merge

post-loop-break64:                                ; No predecessors!
  unreachable

ifmerge65:                                        ; preds = %ifmerge61
  %51 = load i32* %j
  %j66 = add i32 %51, 1, !gla.precision !9
  store i32 %j66, i32* %j
  br label %loop-header58

loop-merge:                                       ; preds = %then63, %then59
  br label %switch-merge55

post-switch-break67:                              ; No predecessors!
  unreachable

post-switch-break70:                              ; No predecessors!
  unreachable

post-switch-break71:                              ; No predecessors!
  unreachable

post-switch-break74:                              ; No predecessors!
  unreachable

then75:                                           ; preds = %switch-merge55
  br label %loop-merge79

post-loop-break76:                                ; No predecessors!
  unreachable

ifmerge77:                                        ; preds = %switch-merge55
  %52 = load i32* %i
  %i78 = add i32 %52, 1, !gla.precision !9
  store i32 %i78, i32* %i
  br label %loop-header

loop-merge79:                                     ; preds = %then75, %then
  %53 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %53, label %switch-segment81 [
    i32 1, label %switch-segment80
  ]

switch-segment80:                                 ; preds = %loop-merge79
  br label %switch-merge82

switch-segment81:                                 ; preds = %loop-merge79
  br label %switch-merge82

switch-merge82:                                   ; preds = %switch-segment81, %switch-segment80
  %54 = load float* %f
  %55 = load i32* %local
  %56 = sitofp i32 %55 to float, !gla.precision !9
  %color = fadd float %54, %56, !gla.precision !9
  store float %color, float* @color
  %param87 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param87, <4 x float>* %param
  %param8588 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param8588, <4 x float>* %param85
  %param8689 = load i32 addrspace(2)* @c, !gla.uniform !1
  store i32 %param8689, i32* %param86
  %57 = call <4 x float> @"foo1(vf4;vf4;i1;"(<4 x float>* %param, <4 x float>* %param85, i32* %param86)
  %58 = extractelement <4 x float> %57, i32 1, !gla.precision !9
  %59 = load float* @color
  %color90 = fadd float %59, %58, !gla.precision !9
  store float %color90, float* @color
  %param9194 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param9194, <4 x float>* %param91
  %param9295 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param9295, <4 x float>* %param92
  %param9396 = load i32 addrspace(2)* @c, !gla.uniform !1
  store i32 %param9396, i32* %param93
  %60 = call <4 x float> @"foo2(vf4;vf4;i1;"(<4 x float>* %param91, <4 x float>* %param92, i32* %param93)
  %61 = extractelement <4 x float> %60, i32 2, !gla.precision !9
  %62 = load float* @color
  %color97 = fadd float %62, %61, !gla.precision !9
  store float %color97, float* @color
  br label %stage-epilogue

post-switch-break83:                              ; No predecessors!
  unreachable

post-switch-break84:                              ; No predecessors!
  unreachable

stage-epilogue:                                   ; preds = %switch-merge82
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: alwaysinline
define internal fastcc <4 x float> @"foo1(vf4;vf4;i1;"(<4 x float>*, <4 x float>*, i32*) #0 {
entry:
  %3 = load i32* %2
  switch i32 %3, label %switch-merge [
    i32 0, label %switch-segment
    i32 2, label %switch-segment1
    i32 1, label %switch-segment1
    i32 3, label %switch-segment2
  ]

switch-segment:                                   ; preds = %entry
  %4 = load <4 x float>* %0
  ret <4 x float> %4

switch-segment1:                                  ; preds = %entry, %entry
  %5 = load <4 x float>* %1
  ret <4 x float> %5

switch-segment2:                                  ; preds = %entry
  %6 = load <4 x float>* %0
  %7 = load <4 x float>* %1
  %8 = fmul <4 x float> %6, %7, !gla.precision !9
  ret <4 x float> %8

switch-merge:                                     ; preds = %entry
  ret <4 x float> zeroinitializer

post-return:                                      ; No predecessors!
  unreachable

post-return3:                                     ; No predecessors!
  unreachable

post-return4:                                     ; No predecessors!
  unreachable

post-return5:                                     ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc <4 x float> @"foo2(vf4;vf4;i1;"(<4 x float>*, <4 x float>*, i32*) #0 {
entry:
  %3 = load i32* %2
  switch i32 %3, label %switch-merge [
    i32 0, label %switch-segment
    i32 2, label %switch-segment1
    i32 1, label %switch-segment2
    i32 3, label %switch-segment3
  ]

switch-segment:                                   ; preds = %entry
  %4 = load <4 x float>* %0
  ret <4 x float> %4

switch-segment1:                                  ; preds = %entry
  ret <4 x float> <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>

switch-segment2:                                  ; preds = %entry
  %5 = load <4 x float>* %1
  ret <4 x float> %5

switch-segment3:                                  ; preds = %entry
  %6 = load <4 x float>* %0
  %7 = load <4 x float>* %1
  %8 = fmul <4 x float> %6, %7, !gla.precision !9
  ret <4 x float> %8

switch-merge:                                     ; preds = %entry
  ret <4 x float> zeroinitializer

post-return:                                      ; No predecessors!
  unreachable

post-return4:                                     ; No predecessors!
  unreachable

post-return5:                                     ; No predecessors!
  unreachable

post-return6:                                     ; No predecessors!
  unreachable

post-return7:                                     ; No predecessors!
  unreachable
}

; Function Attrs: nounwind readnone
declare float @llvm.gla.fSin.f32.f32(float) #1

; Function Attrs: nounwind readnone
declare float @llvm.gla.fCos.f32.f32(float) #1

; Function Attrs: nounwind readnone
declare float @llvm.gla.fTan.f32.f32(float) #1

attributes #0 = { alwaysinline }
attributes #1 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.uniforms = !{!1, !3, !4}
!gla.inputs = !{!5}
!gla.outputs = !{!7}

!0 = !{!"main", i32 15}
!1 = !{!"c", i32 12, i32* @c_typeProxy, !2}
!2 = !{i32 0, i32 2, i32 1024, null, i32 -1, i32 0, i32 -1, i32 0, i32 -1}
!3 = !{!"d", i32 12, i32* @d_typeProxy, !2}
!4 = !{!"v", i32 12, <4 x float>* @v_typeProxy, !2}
!5 = !{!"x", i32 1, float* @x_typeProxy, !6}
!6 = !{i32 0, i32 2, i32 1024, null, i32 1, i32 0, i32 -1, i32 0, i32 -1}
!7 = !{!"color", i32 7, float* @color_typeProxy, !8}
!8 = !{i32 0, i32 2, i32 1025, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!9 = !{i32 2}
LunarGOO: /home/greg/ss/LunarGLASS.36/Core/LLVM/llvm-3.6.2/lib/Analysis/ScalarEvolution.cpp:4391: unsigned int llvm::ScalarEvolution::getSmallConstantTripCount(llvm::Loop*, llvm::BasicBlock*): Assertion `L->isLoopExiting(ExitingBlock) && "Exiting block must actually branch out of the loop!"' failed.
