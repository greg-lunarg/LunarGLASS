
Top IR:
; ModuleID = 'Glslang'

%s = type { <4 x i32> }

@u = external addrspace(2) constant float
@tempReturn = internal global i32 0
@gl_FragColor = global <4 x float> zeroinitializer

define fastcc void @main() {
entry:
  %gl_FragColor = alloca <4 x float>
  %arg = alloca float
  %tempArg = alloca i32
  %param13 = alloca i32
  %param12 = alloca <3 x float>
  %param11 = alloca float
  %ret = alloca float
  %e = alloca i32
  %param5 = alloca i32
  %param4 = alloca i32
  %param3 = alloca i32
  %param2 = alloca i32
  %param1 = alloca i32
  %param = alloca i32
  %color = alloca i32
  %f = alloca %s
  %t = alloca i32
  br label %mainBody

mainBody:                                         ; preds = %entry
  store i32 2, i32* %t
  %0 = getelementptr %s* %f, i32 0, i32 0, i32 1
  store i32 32, i32* %0
  store i32 1, i32* %param
  store i32 2, i32* %param1
  %1 = load i32* %t
  %2 = load i32* %t
  %param26 = add i32 %1, %2
  store i32 %param26, i32* %param2
  store i32 8, i32* %param3
  %3 = getelementptr %s* %f, i32 0, i32 0
  %4 = load <4 x i32>* %3
  %param57 = extractelement <4 x i32> %4, i32 1
  store i32 %param57, i32* %param5
  %color9 = call i32 @"foo(i1;i1;i1;i1;i1;i1;"(i32* %param, i32* %param1, i32* %param2, i32* %param3, i32* %param4, i32* %param5)
  %e8 = load i32* %param4
  store i32 %e8, i32* %e
  %5 = load i32* %param5
  %6 = getelementptr %s* %f, i32 0, i32 0, i32 1
  store i32 %5, i32* %6
  store i32 %color9, i32* %color
  %7 = load i32* %e
  %8 = getelementptr %s* %f, i32 0, i32 0
  %9 = load <4 x i32>* %8
  %10 = extractelement <4 x i32> %9, i32 1
  %11 = add i32 %7, %10
  %12 = mul i32 128, %11
  %13 = load i32* %color
  %color10 = add i32 %13, %12
  store i32 %color10, i32* %color
  store float 4.000000e+00, float* %param11
  store <3 x float> <float 1.000000e+00, float 2.000000e+00, float 3.000000e+00>, <3 x float>* %param12
  %tempReturn = call i32 @"foo2(f1;vf3;i1;"(float* %param11, <3 x float>* %param12, i32* %param13)
  %tempArg14 = load i32* %param13
  store i32 %tempArg14, i32* %tempArg
  store i32 %tempReturn, i32* @tempReturn
  %14 = load i32* %tempArg
  %arg15 = sitofp i32 %14 to float
  store float %arg15, float* %arg
  %15 = load i32* @tempReturn
  %ret16 = sitofp i32 %15 to float
  store float %ret16, float* %ret
  %16 = load float* %ret
  %17 = load float* %arg
  %18 = fadd float %16, %17
  %19 = fptosi float %18 to i32
  %20 = load i32* %color
  %color17 = add i32 %20, %19
  store i32 %color17, i32* %color
  %21 = call i32 @"foo3("()
  %22 = load i32* %color
  %color18 = add i32 %22, %21
  store i32 %color18, i32* %color
  %23 = load i32* %color
  %24 = sitofp i32 %23 to float
  %25 = load <4 x float>* %gl_FragColor
  %26 = insertelement <4 x float> undef, float %24, i32 0
  %27 = insertelement <4 x float> %26, float %24, i32 1
  %28 = insertelement <4 x float> %27, float %24, i32 2
  %gl_FragColor19 = insertelement <4 x float> %28, float %24, i32 3
  store <4 x float> %gl_FragColor19, <4 x float>* @gl_FragColor
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %mainBody
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: alwaysinline
define internal fastcc i32 @"foo(i1;i1;i1;i1;i1;i1;"(i32*, i32*, i32*, i32*, i32*, i32*) #0 {
entry:
  %sum = alloca i32
  %6 = load i32* %0
  %7 = load i32* %1
  %8 = add i32 %6, %7
  %9 = load i32* %2
  %10 = add i32 %8, %9
  %11 = load i32* %3
  %12 = add i32 %10, %11
  %13 = load i32* %5
  %sum1 = add i32 %12, %13
  store i32 %sum1, i32* %sum
  %14 = load i32* %0
  %15 = mul i32 %14, 64
  store i32 %15, i32* %0
  %16 = load i32* %2
  %17 = mul i32 %16, 64
  store i32 %17, i32* %2
  store i32 1024, i32* %4
  %18 = load i32* %5
  %19 = mul i32 %18, 64
  store i32 %19, i32* %5
  %20 = load i32* %0
  %21 = load i32* %1
  %22 = mul i32 64, %21
  %23 = add i32 %20, %22
  %24 = load i32* %2
  %25 = add i32 %23, %24
  %26 = load i32* %3
  %27 = mul i32 64, %26
  %28 = add i32 %25, %27
  %29 = load i32* %4
  %30 = add i32 %28, %29
  %31 = load i32* %5
  %32 = add i32 %30, %31
  %33 = load i32* %sum
  %sum2 = add i32 %33, %32
  store i32 %sum2, i32* %sum
  %34 = load i32* %sum
  ret i32 %34

post-return:                                      ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc i32 @"foo2(f1;vf3;i1;"(float*, <3 x float>*, i32*) #0 {
entry:
  %3 = load float* %0
  %4 = fmul float 3.000000e+00, %3
  %5 = fptosi float %4 to i32
  store i32 %5, i32* %2
  %6 = load <3 x float>* %1
  %7 = extractelement <3 x float> %6, i32 1
  %8 = fmul float 5.000000e+00, %7
  %9 = fptosi float %8 to i32
  ret i32 %9

post-return:                                      ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc i32 @"foo3("() #0 {
entry:
  %0 = load float addrspace(2)* @u, !gla.uniform !0
  %1 = fcmp ogt float %0, 0x40099999A0000000
  br i1 %1, label %then, label %ifmerge

then:                                             ; preds = %entry
  call void @llvm.gla.discard()
  ret i32 1000000

post-return:                                      ; No predecessors!
  unreachable

ifmerge:                                          ; preds = %entry
  ret i32 2000000

post-return1:                                     ; No predecessors!
  unreachable
}

; Function Attrs: nounwind
declare void @llvm.gla.discard() #1

attributes #0 = { alwaysinline }
attributes #1 = { nounwind }

!gla.uniforms = !{!0}
!gla.entrypoint = !{!2}
!gla.outputs = !{!3}

!0 = !{!"u", i32 12, float* @u_typeProxy, !1}
!1 = !{i32 0, i32 0, i32 1024, null, i32 -1, i32 0, i32 -1, i32 0, i32 -1}
!2 = !{!"main", i32 15}
!3 = !{!"gl_FragColor", i32 7, <4 x float>* @gl_FragColor_typeProxy, !4}
!4 = !{i32 0, i32 0, i32 1024, null, i32 0, i32 43, i32 -1, i32 0, i32 -1}


Bottom IR:
; ModuleID = 'Glslang'
target datalayout = "e-p:32:32"

%s = type { <4 x i32> }

@u = external addrspace(2) constant float
@gl_FragColor = global <4 x float> zeroinitializer

define fastcc void @main() {
entry:
  %f = alloca %s
  %0 = getelementptr %s* %f, i32 0, i32 0, i32 1
  store i32 32, i32* %0
  %1 = getelementptr %s* %f, i32 0, i32 0
  %2 = load <4 x i32>* %1
  %param57 = extractelement <4 x i32> %2, i32 1
  %3 = shl i32 %param57, 6
  %4 = mul i32 %param57, 65
  store i32 %3, i32* %0
  %5 = load <4 x i32>* %1
  %6 = extractelement <4 x i32> %5, i32 1
  %7 = shl i32 %6, 7
  %8 = load float addrspace(2)* @u, !gla.uniform !0
  %9 = fcmp ogt float %8, 0x40099999A0000000
  br i1 %9, label %then.i, label %"foo3(.exit"

then.i:                                           ; preds = %entry
  call void @llvm.gla.discard()
  br label %"foo3(.exit"

"foo3(.exit":                                     ; preds = %entry, %then.i
  %10 = phi i32 [ 1000000, %then.i ], [ 2000000, %entry ]
  %11 = add i32 %4, 133093
  %color17 = add i32 %11, %7
  %color18 = add i32 %color17, %10
  %12 = sitofp i32 %color18 to float
  %13 = call <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float %12, <4 x i32> zeroinitializer)
  store <4 x float> %13, <4 x float>* @gl_FragColor
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %"foo3(.exit"
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind
declare void @llvm.gla.discard() #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float, <4 x i32>) #1

attributes #0 = { nounwind }
attributes #1 = { nounwind readnone }

!gla.uniforms = !{!0}
!gla.entrypoint = !{!2}
!gla.outputs = !{!3}

!0 = !{!"u", i32 12, float* @u_typeProxy, !1}
!1 = !{i32 0, i32 0, i32 1024, null, i32 -1, i32 0, i32 -1, i32 0, i32 -1}
!2 = !{!"main", i32 15}
!3 = !{!"gl_FragColor", i32 7, <4 x float>* @gl_FragColor_typeProxy, !4}
!4 = !{i32 0, i32 0, i32 1024, null, i32 0, i32 43, i32 -1, i32 0, i32 -1}
#version 400 core
// LunarGOO output
struct s {
	ivec4 member0;
};
uniform float u;
const int C_32 = 32;
const int C_6 = 6;
const int C_65 = 65;
const int C_7 = 7;
const float C_3d2 = 3.2;
const int C_2000000 = 2000000;
const int C_1000000 = 1000000;
const int C_133093 = 133093;

void main()
{
	int Lg_1;
	s Lg_2;
	Lg_2.member0.y = C_32;
	int H_cptn74 = Lg_2.member0.y << C_6;
	int H_d6n9hr1 = Lg_2.member0.y * C_65;
	Lg_2.member0.y = H_cptn74;
	int H_befnh4 = Lg_2.member0.y << C_7;
	bool H_3xblpb1 = u > C_3d2;
	Lg_1 = C_2000000;
	if (H_3xblpb1) {
		discard;
		Lg_1 = C_1000000;
	} else {
		int H_mfcap2 = H_d6n9hr1 + C_133093;
		int color = H_befnh4 + H_mfcap2;
		int color1 = Lg_1 + color;
		float H_wl4rkc = float(color1);
		vec4 H_urpfn61 = vec4(H_wl4rkc);
		gl_FragColor = H_urpfn61;
		
	}
	
}

